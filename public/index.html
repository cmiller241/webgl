<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Phaser Game Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body style="background-color:#000; overflow: hidden">
  <div id="game-container"></div>
  <script>
    const config = {
      type: Phaser.AUTO,
      width: window.innerWidth,
      height: window.innerHeight,
      parent: 'game-container',
      backgroundColor: '#000000',
      scale: {
        mode: Phaser.Scale.RESIZE,
        autoCenter: Phaser.Scale.CENTER_BOTH
      },
      scene: {
        preload: preload,
        create: create,
        update: update
      },
      pixelArt: true,
      fps: { target: 60 }
    };

    let game = new Phaser.Game(config);
    let cameraSpeed = 5;
    let keys;
    let mapData;
    let grassTexture, treeTexture, heroTexture;
    let fpsText, fpsBox;
    let time = 0;
    let frameTimes = [];
    let lastFpsUpdate = 0;
    const maxFrameTimes = 60;
    const fpsUpdateInterval = 0.1;
    let socket;
    let grassGroup, trunkGroup, leavesGroup, heroGroup;
    let grassFrame, trunkFrame, leavesFrame, heroFrame;
    let tilemap, grassLayer;
    let heroPositions = []; // Store hero pixel coordinates { x, y }

    function preload() {
      this.load.json('map', 'js/map.json');
      this.load.image('grass', 'assets/sprites2.png');
      this.load.image('tree', 'assets/tree3.png');
      this.load.image('hero', 'assets/sprites-fixedgrid.png');
    }

function create() {
  mapData = this.cache.json.get('map');

  // Function to check map dimensions
  function checkMapDimensions(map, expectedCols = null) {
    if (!Array.isArray(map) || !map.length || !Array.isArray(map[0])) {
      console.error("Error: Map data is not a valid 2D array.");
      return false;
    }

    const numRows = map.length;
    const referenceCols = expectedCols !== null ? expectedCols : map[0].length;
    
    console.log(`Checking map: ${map[0].length}x${numRows}, expecting ${referenceCols} columns per row.`);

    let isValid = true;
    for (let row = 0; row < numRows; row++) {
      if (!Array.isArray(map[row]) || map[row].length !== referenceCols) {
        console.error(`Row ${row} has ${map[row]?.length || 0} columns, expected ${referenceCols}.`);
        isValid = false;
      }
    }

    if (isValid) {
      console.log("Map dimensions are valid.");
    } else {
      console.error("Map validation failed. Please fix map.json.");
    }
    return isValid;
  }

  // Validate map dimensions before proceeding
  if (!checkMapDimensions(mapData)) {
    console.error("Stopping game initialization due to invalid map.");
    return; // Halt execution
  }

  console.log('Map loaded:', mapData[0].length, 'x', mapData.length);
  console.log(`Canvas size: ${window.innerWidth}x${window.innerHeight}`);

  // Rest of your existing create function code...
  grassTexture = this.textures.get('grass');
  treeTexture = this.textures.get('tree');
  heroTexture = this.textures.get('hero');

  grassFrame = new Phaser.Textures.Frame(grassTexture, 'grass', 0, 225, 1, 30, 30);
  trunkFrame = new Phaser.Textures.Frame(treeTexture, 'tree_trunk', 0, 0, 0, 480, 480);
  leavesFrame = new Phaser.Textures.Frame(treeTexture, 'tree_leaves', 0, 480, 0, 480, 480);
  heroFrame = new Phaser.Textures.Frame(heroTexture, 'hero', 0, 0, 0, 112, 112);

  tilemap = this.make.tilemap({
    data: mapData.map(row => row.map(cell => cell[0] <= 512 ? 0 : -1)),
    tileWidth: 32,
    tileHeight: 32
  });
  
      const tileset = tilemap.addTilesetImage('grass', 'grass', 32, 32, 0, 0, 0);
      grassLayer = tilemap.createLayer(0, tileset, 0, 0);
      grassLayer.setDepth(0);
      grassLayer.setScale(1);

      grassGroup = this.add.group({
        maxSize: 2000,
        createCallback: (sprite) => {
          sprite.setOrigin(0);
          sprite.setActive(false);
          sprite.setVisible(false);
          sprite.setDepth(0);
          sprite.setAngle(0);
          sprite.setPosition(0, 0);
          sprite.setScale(1);
        }
      });

      trunkGroup = this.add.group({
        maxSize: 500,
        createCallback: (sprite) => {
          sprite.setOrigin(0.5, 0.5);
          sprite.setActive(false);
          sprite.setVisible(false);
          sprite.setDepth(0);
          sprite.setAngle(0);
          sprite.setPosition(0, 0);
          sprite.setScale(1);
          sprite.setFrame(trunkFrame);
          sprite.setDisplaySize(480, 480);
        }
      });

      leavesGroup = this.add.group({
        maxSize: 500,
        createCallback: (sprite) => {
          sprite.setOrigin(0.5, 0.5);
          sprite.setActive(false);
          sprite.setVisible(false);
          sprite.setDepth(0);
          sprite.setAngle(0);
          sprite.setPosition(0, 0);
          sprite.setScale(1);
          sprite.setFrame(leavesFrame);
          sprite.setDisplaySize(480, 480);
        }
      });

      heroGroup = this.add.group({
        maxSize: 10000,
        createCallback: (sprite) => {
          sprite.setOrigin(0.5, 0.5);
          sprite.setActive(false);
          sprite.setVisible(false);
          sprite.setDepth(0);
          sprite.setAngle(0);
          sprite.setPosition(0, 0);
          sprite.setScale(1);
          sprite.setFrame(heroFrame);
          sprite.setDisplaySize(112, 112);
        }
      });

      grassGroup.createMultiple({ key: 'grass', repeat: 1500 });
      trunkGroup.createMultiple({ key: 'tree', repeat: 500 });
      leavesGroup.createMultiple({ key: 'tree', repeat: 500 });
      heroGroup.createMultiple({ key: 'hero', repeat: 1000 });

      // Place heroes randomly at pixel coordinates on grass
      const numHeroes = 10000;
      const mapWidth = mapData[0].length * 32;
      const mapHeight = mapData.length * 32;
      for (let i = 0; i < numHeroes; i++) {
        let placed = false;
        let attempts = 0;
        const maxAttempts = 100;
        while (!placed && attempts < maxAttempts) {
          const x = Math.random() * mapWidth;
          const y = Math.random() * mapHeight;
          const mapCol = Math.floor(x / 32);
          const mapRow = Math.floor(y / 32);
          if (mapRow >= 0 && mapRow < mapData.length && mapCol >= 0 && mapCol < mapData[0].length) {
            const tileValue = mapData[mapRow][mapCol][0];
            const tile = tileValue - 1;
            if (tile <= 512 && tile !== 511) { // Grass, not tree
              heroPositions.push({ x, y });
              placed = true;
            }
          }
          attempts++;
        }
      }
      console.log(`Placed ${heroPositions.length} heroes`);

      fpsBox = this.add.rectangle(10, 10, 180, 60, 0x000000).setOrigin(0).setAlpha(0.5);
      fpsBox.setScrollFactor(0);
      fpsBox.setDepth(10000);

      fpsText = this.add.text(20, 20, 'FPS: 0', {
        fontFamily: 'Arial, sans-serif',
        fontSize: '36px',
        color: '#ffffff'
      }).setOrigin(0);
      fpsText.setScrollFactor(0);
      fpsText.setDepth(10001);

      this.cameras.main.setZoom(1);
      this.cameras.main.setBounds(
        -window.innerWidth / 2,
        -window.innerHeight / 2,
        mapData[0].length * 32 + window.innerWidth,
        mapData.length * 32 + window.innerHeight
      );
      this.cameras.main.roundPx = false;

      keys = this.input.keyboard.addKeys({
        ArrowLeft: Phaser.Input.Keyboard.KeyCodes.LEFT,
        ArrowRight: Phaser.Input.Keyboard.KeyCodes.RIGHT,
        ArrowUp: Phaser.Input.Keyboard.KeyCodes.UP,
        ArrowDown: Phaser.Input.Keyboard.KeyCodes.DOWN
      });

      socket = io();
      socket.on('connect', () => {
        console.log('Connected to server:', socket.id);
      });

      console.log('Init complete');
    }

    function update(gameTime, delta) {
      let cameraX = this.cameras.main.scrollX;
      let cameraY = this.cameras.main.scrollY;

      if (keys.ArrowLeft.isDown) cameraX -= cameraSpeed;
      if (keys.ArrowRight.isDown) cameraX += cameraSpeed;
      if (keys.ArrowUp.isDown) cameraY -= cameraSpeed;
      if (keys.ArrowDown.isDown) cameraY += cameraSpeed;

      cameraX = Math.round(cameraX);
      cameraY = Math.round(cameraY);
      this.cameras.main.scrollX = cameraX;
      this.cameras.main.scrollY = cameraY;

      const fps = delta > 0 ? 1000 / delta : 0;
      frameTimes.push(fps);
      if (frameTimes.length > maxFrameTimes) frameTimes.shift();
      const avgFps = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;

      if (time - lastFpsUpdate >= fpsUpdateInterval) {
        fpsText.setText(`FPS: ${Math.round(avgFps)}`);
        lastFpsUpdate = time / 1000;
      }

      render.call(this, cameraX, cameraY);

      time += delta / 1000;
    }

    function render(cameraX, cameraY) {
      trunkGroup.getChildren().forEach(sprite => {
        sprite.setActive(false);
        sprite.setVisible(false);
        sprite.setPosition(0, 0);
        sprite.setAngle(0);
      });
      leavesGroup.getChildren().forEach(sprite => {
        sprite.setActive(false);
        sprite.setVisible(false);
        sprite.setPosition(0, 0);
        sprite.setAngle(0);
      });
      heroGroup.getChildren().forEach(sprite => {
        sprite.setActive(false);
        sprite.setVisible(false);
        sprite.setPosition(0, 0);
      });

      const spriteWidth = 32;
      const spriteHeight = 32;
      const canvasWidth = game.config.width;
      const canvasHeight = game.config.height;

      const startCol = Math.floor(cameraX / spriteWidth) - 5;
      const startRow = Math.floor(cameraY / spriteHeight) - 5;
      const maxCols = Math.ceil(canvasWidth / spriteWidth) + 10;
      const maxRows = Math.ceil(canvasHeight / spriteHeight) + 10;

      let grassCount = 0;
      let treeCount = 0;
      let heroCount = 0;

      // Render trees
      for (let row = -10; row <= maxRows + 5; row++) {
        for (let col = -5; col <= maxCols + 5; col++) {
          const mapRow = startRow + row;
          const mapCol = startCol + col;
          if (mapRow < 0 || mapRow >= mapData.length || mapCol < 0 || mapCol >= mapData[0].length) continue;

          const tileValue = mapData[mapRow][mapCol][0];
          const tile = tileValue - 1;

          if (tile <= 512) {
            grassCount++;
          }

          if (treeCount >= 500) continue;

          if (tile === 511) {
            const amplitude = (3 * Math.PI) / 180;
            const rotation = amplitude * Math.sin(2 * time + 0.5 * mapCol);

            const centerX = Math.floor(mapCol * spriteWidth - 240 + 16) + 240;
            const baseY = Math.floor(mapRow * spriteHeight - 240 + 16) + 480;

            const trunkSprite = trunkGroup.get(centerX, baseY, 'tree');
            if (trunkSprite) {
              trunkSprite.setDepth(mapRow * 10 + 1);
              trunkSprite.setAngle(rotation * 180 / Math.PI);
              trunkSprite.y = baseY - 240;
              trunkSprite.setActive(true);
              trunkSprite.setVisible(true);
              treeCount++;
            }

            const leavesSprite = leavesGroup.get(centerX, baseY - 1, 'tree');
            if (leavesSprite) {
              leavesSprite.setDepth(mapRow * 10 + 2);
              leavesSprite.setAngle(rotation * 180 / Math.PI);
              leavesSprite.y = baseY - 240;
              leavesSprite.setActive(true);
              leavesSprite.setVisible(true);

              const tintR = 0x80 + Math.floor((mapCol % 10) * 25);
              const tintG = 0x80 + Math.floor((mapRow % 10) * 8);
              const tintB = 0x10;
              const tint = (tintR << 16) | (tintG << 8) | tintB;
              leavesSprite.setTint(tint);

              treeCount++;
            }
          }
        }
      }

      // Render heroes
      heroPositions.forEach(({ x, y }) => {
        if (x >= cameraX - 112 && x <= cameraX + canvasWidth + 112 &&
            y >= cameraY - 112 && y <= cameraY + canvasHeight + 112) {
          const heroSprite = heroGroup.get(x, y, 'hero');
          if (heroSprite) {
            heroSprite.setDepth((y / spriteHeight) * 10 + 1.5); // Depth based on precise y
            heroSprite.setActive(true);
            heroSprite.setVisible(true);
            heroCount++;
          }
        }
      });

      console.log(`Rendered ${grassCount} grass tiles, ${treeCount} tree sprites, ${heroCount} heroes`);
    }
  </script>
</body>
</html>